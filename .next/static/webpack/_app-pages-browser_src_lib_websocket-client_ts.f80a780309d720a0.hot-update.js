"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_websocket-client_ts",{

/***/ "(app-pages-browser)/./src/lib/websocket-client.ts":
/*!*************************************!*\
  !*** ./src/lib/websocket-client.ts ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WorkflowWebSocketClient: function() { return /* binding */ WorkflowWebSocketClient; }\n/* harmony export */ });\nclass WorkflowWebSocketClient {\n    connect() {\n        return new Promise((resolve, reject)=>{\n            if (this.isConnecting || this.ws && this.ws.readyState === WebSocket.OPEN) {\n                resolve();\n                return;\n            }\n            this.isConnecting = true;\n            try {\n                const protocol = window.location.protocol === \"https:\" ? \"wss:\" : \"ws:\";\n                const wsUrl = \"\".concat(protocol, \"//\").concat(window.location.host, \"/api/workflows/ws?workflowId=\").concat(this.options.workflowId, \"&token=\").concat(this.options.token);\n                this.ws = new WebSocket(wsUrl);\n                this.ws.onopen = ()=>{\n                    var _this_options_onConnect, _this_options;\n                    logger.info(\"WebSocket connected\", {\n                        workflowId: this.options.workflowId,\n                        component: \"websocket-client\"\n                    });\n                    this.isConnecting = false;\n                    this.reconnectAttempts = 0;\n                    this.startPingTimer();\n                    (_this_options_onConnect = (_this_options = this.options).onConnect) === null || _this_options_onConnect === void 0 ? void 0 : _this_options_onConnect.call(_this_options);\n                    resolve();\n                };\n                this.ws.onmessage = (event)=>{\n                    try {\n                        const message = JSON.parse(event.data);\n                        this.handleMessage(message);\n                    } catch (error) {\n                        console.error(\"Error parsing WebSocket message:\", error);\n                    }\n                };\n                this.ws.onclose = (event)=>{\n                    var _this_options_onDisconnect, _this_options;\n                    logger.info(\"WebSocket closed\", {\n                        code: event.code,\n                        reason: event.reason,\n                        workflowId: this.options.workflowId,\n                        component: \"websocket-client\"\n                    });\n                    this.isConnecting = false;\n                    this.stopPingTimer();\n                    (_this_options_onDisconnect = (_this_options = this.options).onDisconnect) === null || _this_options_onDisconnect === void 0 ? void 0 : _this_options_onDisconnect.call(_this_options);\n                    if (this.shouldReconnect && this.reconnectAttempts < this.options.maxReconnectAttempts) {\n                        this.scheduleReconnect();\n                    }\n                };\n                this.ws.onerror = (error)=>{\n                    var _this_options_onError, _this_options, _this_ws;\n                    console.error(\"WebSocket error:\", error);\n                    this.isConnecting = false;\n                    (_this_options_onError = (_this_options = this.options).onError) === null || _this_options_onError === void 0 ? void 0 : _this_options_onError.call(_this_options, error);\n                    if (((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.CONNECTING) {\n                        reject(new Error(\"Failed to connect to WebSocket\"));\n                    }\n                };\n            } catch (error) {\n                this.isConnecting = false;\n                reject(error);\n            }\n        });\n    }\n    disconnect() {\n        this.shouldReconnect = false;\n        this.stopPingTimer();\n        this.clearReconnectTimer();\n        if (this.ws) {\n            this.ws.close(1000, \"Client disconnect\");\n            this.ws = null;\n        }\n    }\n    sendMessage(message) {\n        if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n            this.ws.send(JSON.stringify(message));\n        } else {\n            console.warn(\"WebSocket not connected, cannot send message:\", message);\n        }\n    }\n    sendUserResponse(agentId, response) {\n        this.sendMessage({\n            type: \"user_response\",\n            agentId,\n            response\n        });\n    }\n    sendWorkflowControl(action) {\n        this.sendMessage({\n            type: \"workflow_control\",\n            action\n        });\n    }\n    requestStatus() {\n        this.sendMessage({\n            type: \"request_status\"\n        });\n    }\n    handleMessage(message) {\n        var _this_options_onMessage, _this_options;\n        // Handle pong messages\n        if (message.type === \"pong\") {\n            return;\n        }\n        (_this_options_onMessage = (_this_options = this.options).onMessage) === null || _this_options_onMessage === void 0 ? void 0 : _this_options_onMessage.call(_this_options, message);\n    }\n    startPingTimer() {\n        this.stopPingTimer();\n        this.pingTimer = setInterval(()=>{\n            this.sendMessage({\n                type: \"ping\"\n            });\n        }, 30000) // Ping every 30 seconds\n        ;\n    }\n    stopPingTimer() {\n        if (this.pingTimer) {\n            clearInterval(this.pingTimer);\n            this.pingTimer = null;\n        }\n    }\n    scheduleReconnect() {\n        this.clearReconnectTimer();\n        this.reconnectAttempts++;\n        const delay = Math.min(this.options.reconnectInterval * Math.pow(2, this.reconnectAttempts - 1), 30000 // Max 30 seconds\n        );\n        logger.info(\"Scheduling WebSocket reconnect\", {\n            attempt: this.reconnectAttempts,\n            delayMs: delay,\n            workflowId: this.options.workflowId,\n            component: \"websocket-client\"\n        });\n        this.reconnectTimer = setTimeout(()=>{\n            if (this.shouldReconnect) {\n                this.connect().catch((error)=>{\n                    console.error(\"Reconnect failed:\", error);\n                });\n            }\n        }, delay);\n    }\n    clearReconnectTimer() {\n        if (this.reconnectTimer) {\n            clearTimeout(this.reconnectTimer);\n            this.reconnectTimer = null;\n        }\n    }\n    get isConnected() {\n        var _this_ws;\n        return ((_this_ws = this.ws) === null || _this_ws === void 0 ? void 0 : _this_ws.readyState) === WebSocket.OPEN;\n    }\n    get connectionState() {\n        if (!this.ws) return \"disconnected\";\n        switch(this.ws.readyState){\n            case WebSocket.CONNECTING:\n                return \"connecting\";\n            case WebSocket.OPEN:\n                return \"connected\";\n            case WebSocket.CLOSING:\n                return \"closing\";\n            case WebSocket.CLOSED:\n                return \"disconnected\";\n            default:\n                return \"unknown\";\n        }\n    }\n    constructor(options){\n        this.ws = null;\n        this.reconnectAttempts = 0;\n        this.reconnectTimer = null;\n        this.pingTimer = null;\n        this.isConnecting = false;\n        this.shouldReconnect = true;\n        this.options = {\n            reconnectInterval: 5000,\n            maxReconnectAttempts: 10,\n            ...options\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvd2Vic29ja2V0LWNsaWVudC50cyIsIm1hcHBpbmdzIjoiOzs7O0FBYU8sTUFBTUE7SUFpQlhDLFVBQXlCO1FBQ3ZCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztZQUMzQixJQUFJLElBQUksQ0FBQ0MsWUFBWSxJQUFLLElBQUksQ0FBQ0MsRUFBRSxJQUFJLElBQUksQ0FBQ0EsRUFBRSxDQUFDQyxVQUFVLEtBQUtDLFVBQVVDLElBQUksRUFBRztnQkFDM0VOO2dCQUNBO1lBQ0Y7WUFFQSxJQUFJLENBQUNFLFlBQVksR0FBRztZQUVwQixJQUFJO2dCQUNGLE1BQU1LLFdBQVdDLE9BQU9DLFFBQVEsQ0FBQ0YsUUFBUSxLQUFLLFdBQVcsU0FBUztnQkFDbEUsTUFBTUcsUUFBUSxHQUFnQkYsT0FBYkQsVUFBUyxNQUF3RCxPQUFwREMsT0FBT0MsUUFBUSxDQUFDRSxJQUFJLEVBQUMsaUNBQWdFLE9BQWpDLElBQUksQ0FBQ0MsT0FBTyxDQUFDQyxVQUFVLEVBQUMsV0FBNEIsT0FBbkIsSUFBSSxDQUFDRCxPQUFPLENBQUNFLEtBQUs7Z0JBRXJJLElBQUksQ0FBQ1gsRUFBRSxHQUFHLElBQUlFLFVBQVVLO2dCQUV4QixJQUFJLENBQUNQLEVBQUUsQ0FBQ1ksTUFBTSxHQUFHO3dCQVFmO29CQVBBQyxPQUFPQyxJQUFJLENBQUMsdUJBQXVCO3dCQUNqQ0osWUFBWSxJQUFJLENBQUNELE9BQU8sQ0FBQ0MsVUFBVTt3QkFDbkNLLFdBQVc7b0JBQ2I7b0JBQ0EsSUFBSSxDQUFDaEIsWUFBWSxHQUFHO29CQUNwQixJQUFJLENBQUNpQixpQkFBaUIsR0FBRztvQkFDekIsSUFBSSxDQUFDQyxjQUFjO3FCQUNuQiwrQ0FBSSxDQUFDUixPQUFPLEVBQUNTLFNBQVMsY0FBdEI7b0JBQ0FyQjtnQkFDRjtnQkFFQSxJQUFJLENBQUNHLEVBQUUsQ0FBQ21CLFNBQVMsR0FBRyxDQUFDQztvQkFDbkIsSUFBSTt3QkFDRixNQUFNQyxVQUFVQyxLQUFLQyxLQUFLLENBQUNILE1BQU1JLElBQUk7d0JBQ3JDLElBQUksQ0FBQ0MsYUFBYSxDQUFDSjtvQkFDckIsRUFBRSxPQUFPSyxPQUFPO3dCQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DQTtvQkFDcEQ7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDMUIsRUFBRSxDQUFDNEIsT0FBTyxHQUFHLENBQUNSO3dCQVNqQjtvQkFSQVAsT0FBT0MsSUFBSSxDQUFDLG9CQUFvQjt3QkFDOUJlLE1BQU1ULE1BQU1TLElBQUk7d0JBQ2hCQyxRQUFRVixNQUFNVSxNQUFNO3dCQUNwQnBCLFlBQVksSUFBSSxDQUFDRCxPQUFPLENBQUNDLFVBQVU7d0JBQ25DSyxXQUFXO29CQUNiO29CQUNBLElBQUksQ0FBQ2hCLFlBQVksR0FBRztvQkFDcEIsSUFBSSxDQUFDZ0MsYUFBYTtxQkFDbEIsa0RBQUksQ0FBQ3RCLE9BQU8sRUFBQ3VCLFlBQVksY0FBekI7b0JBRUEsSUFBSSxJQUFJLENBQUNDLGVBQWUsSUFBSSxJQUFJLENBQUNqQixpQkFBaUIsR0FBRyxJQUFJLENBQUNQLE9BQU8sQ0FBQ3lCLG9CQUFvQixFQUFHO3dCQUN2RixJQUFJLENBQUNDLGlCQUFpQjtvQkFDeEI7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDbkMsRUFBRSxDQUFDb0MsT0FBTyxHQUFHLENBQUNWO3dCQUdqQixzQ0FFSTtvQkFKSkMsUUFBUUQsS0FBSyxDQUFDLG9CQUFvQkE7b0JBQ2xDLElBQUksQ0FBQzNCLFlBQVksR0FBRztxQkFDcEIsNkNBQUksQ0FBQ1UsT0FBTyxFQUFDNEIsT0FBTyxjQUFwQixzRkFBdUJYO29CQUV2QixJQUFJLGlCQUFJLENBQUMxQixFQUFFLGNBQVAsd0NBQVNDLFVBQVUsTUFBS0MsVUFBVW9DLFVBQVUsRUFBRTt3QkFDaER4QyxPQUFPLElBQUl5QyxNQUFNO29CQUNuQjtnQkFDRjtZQUVGLEVBQUUsT0FBT2IsT0FBTztnQkFDZCxJQUFJLENBQUMzQixZQUFZLEdBQUc7Z0JBQ3BCRCxPQUFPNEI7WUFDVDtRQUNGO0lBQ0Y7SUFFQWMsYUFBYTtRQUNYLElBQUksQ0FBQ1AsZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0YsYUFBYTtRQUNsQixJQUFJLENBQUNVLG1CQUFtQjtRQUV4QixJQUFJLElBQUksQ0FBQ3pDLEVBQUUsRUFBRTtZQUNYLElBQUksQ0FBQ0EsRUFBRSxDQUFDMEMsS0FBSyxDQUFDLE1BQU07WUFDcEIsSUFBSSxDQUFDMUMsRUFBRSxHQUFHO1FBQ1o7SUFDRjtJQUVBMkMsWUFBWXRCLE9BQVksRUFBRTtRQUN4QixJQUFJLElBQUksQ0FBQ3JCLEVBQUUsSUFBSSxJQUFJLENBQUNBLEVBQUUsQ0FBQ0MsVUFBVSxLQUFLQyxVQUFVQyxJQUFJLEVBQUU7WUFDcEQsSUFBSSxDQUFDSCxFQUFFLENBQUM0QyxJQUFJLENBQUN0QixLQUFLdUIsU0FBUyxDQUFDeEI7UUFDOUIsT0FBTztZQUNMTSxRQUFRbUIsSUFBSSxDQUFDLGlEQUFpRHpCO1FBQ2hFO0lBQ0Y7SUFFQTBCLGlCQUFpQkMsT0FBZSxFQUFFQyxRQUFnQixFQUFFO1FBQ2xELElBQUksQ0FBQ04sV0FBVyxDQUFDO1lBQ2ZPLE1BQU07WUFDTkY7WUFDQUM7UUFDRjtJQUNGO0lBRUFFLG9CQUFvQkMsTUFBcUMsRUFBRTtRQUN6RCxJQUFJLENBQUNULFdBQVcsQ0FBQztZQUNmTyxNQUFNO1lBQ05FO1FBQ0Y7SUFDRjtJQUVBQyxnQkFBZ0I7UUFDZCxJQUFJLENBQUNWLFdBQVcsQ0FBQztZQUNmTyxNQUFNO1FBQ1I7SUFDRjtJQUVRekIsY0FBY0osT0FBeUIsRUFBRTtZQU0vQztRQUxBLHVCQUF1QjtRQUN2QixJQUFJLFFBQWlCNkIsSUFBSSxLQUFLLFFBQVE7WUFDcEM7UUFDRjtTQUVBLCtDQUFJLENBQUN6QyxPQUFPLEVBQUM2QyxTQUFTLGNBQXRCLDBGQUF5QmpDO0lBQzNCO0lBRVFKLGlCQUFpQjtRQUN2QixJQUFJLENBQUNjLGFBQWE7UUFDbEIsSUFBSSxDQUFDd0IsU0FBUyxHQUFHQyxZQUFZO1lBQzNCLElBQUksQ0FBQ2IsV0FBVyxDQUFDO2dCQUFFTyxNQUFNO1lBQU87UUFDbEMsR0FBRyxPQUFPLHdCQUF3Qjs7SUFDcEM7SUFFUW5CLGdCQUFnQjtRQUN0QixJQUFJLElBQUksQ0FBQ3dCLFNBQVMsRUFBRTtZQUNsQkUsY0FBYyxJQUFJLENBQUNGLFNBQVM7WUFDNUIsSUFBSSxDQUFDQSxTQUFTLEdBQUc7UUFDbkI7SUFDRjtJQUVRcEIsb0JBQW9CO1FBQzFCLElBQUksQ0FBQ00sbUJBQW1CO1FBQ3hCLElBQUksQ0FBQ3pCLGlCQUFpQjtRQUV0QixNQUFNMEMsUUFBUUMsS0FBS0MsR0FBRyxDQUNwQixJQUFJLENBQUNuRCxPQUFPLENBQUNvRCxpQkFBaUIsR0FBSUYsS0FBS0csR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDOUMsaUJBQWlCLEdBQUcsSUFDdkUsTUFBTSxpQkFBaUI7O1FBR3pCSCxPQUFPQyxJQUFJLENBQUMsa0NBQWtDO1lBQzVDaUQsU0FBUyxJQUFJLENBQUMvQyxpQkFBaUI7WUFDL0JnRCxTQUFTTjtZQUNUaEQsWUFBWSxJQUFJLENBQUNELE9BQU8sQ0FBQ0MsVUFBVTtZQUNuQ0ssV0FBVztRQUNiO1FBRUEsSUFBSSxDQUFDa0QsY0FBYyxHQUFHQyxXQUFXO1lBQy9CLElBQUksSUFBSSxDQUFDakMsZUFBZSxFQUFFO2dCQUN4QixJQUFJLENBQUN0QyxPQUFPLEdBQUd3RSxLQUFLLENBQUN6QyxDQUFBQTtvQkFDbkJDLFFBQVFELEtBQUssQ0FBQyxxQkFBcUJBO2dCQUNyQztZQUNGO1FBQ0YsR0FBR2dDO0lBQ0w7SUFFUWpCLHNCQUFzQjtRQUM1QixJQUFJLElBQUksQ0FBQ3dCLGNBQWMsRUFBRTtZQUN2QkcsYUFBYSxJQUFJLENBQUNILGNBQWM7WUFDaEMsSUFBSSxDQUFDQSxjQUFjLEdBQUc7UUFDeEI7SUFDRjtJQUVBLElBQUlJLGNBQXVCO1lBQ2xCO1FBQVAsT0FBTyxpQkFBSSxDQUFDckUsRUFBRSxjQUFQLHdDQUFTQyxVQUFVLE1BQUtDLFVBQVVDLElBQUk7SUFDL0M7SUFFQSxJQUFJbUUsa0JBQTBCO1FBQzVCLElBQUksQ0FBQyxJQUFJLENBQUN0RSxFQUFFLEVBQUUsT0FBTztRQUVyQixPQUFRLElBQUksQ0FBQ0EsRUFBRSxDQUFDQyxVQUFVO1lBQ3hCLEtBQUtDLFVBQVVvQyxVQUFVO2dCQUFFLE9BQU87WUFDbEMsS0FBS3BDLFVBQVVDLElBQUk7Z0JBQUUsT0FBTztZQUM1QixLQUFLRCxVQUFVcUUsT0FBTztnQkFBRSxPQUFPO1lBQy9CLEtBQUtyRSxVQUFVc0UsTUFBTTtnQkFBRSxPQUFPO1lBQzlCO2dCQUFTLE9BQU87UUFDbEI7SUFDRjtJQTFMQUMsWUFBWWhFLE9BQStCLENBQUU7YUFSckNULEtBQXVCO2FBRXZCZ0Isb0JBQW9CO2FBQ3BCaUQsaUJBQXdDO2FBQ3hDVixZQUFtQzthQUNuQ3hELGVBQWU7YUFDZmtDLGtCQUFrQjtRQUd4QixJQUFJLENBQUN4QixPQUFPLEdBQUc7WUFDYm9ELG1CQUFtQjtZQUNuQjNCLHNCQUFzQjtZQUN0QixHQUFHekIsT0FBTztRQUNaO0lBQ0Y7QUFxTEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi93ZWJzb2NrZXQtY2xpZW50LnRzPzYzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2ViU29ja2V0TWVzc2FnZSB9IGZyb20gJy4vd2Vic29ja2V0LXNlcnZlcidcblxuZXhwb3J0IGludGVyZmFjZSBXZWJTb2NrZXRDbGllbnRPcHRpb25zIHtcbiAgd29ya2Zsb3dJZDogc3RyaW5nXG4gIHRva2VuOiBzdHJpbmdcbiAgb25NZXNzYWdlPzogKG1lc3NhZ2U6IFdlYlNvY2tldE1lc3NhZ2UpID0+IHZvaWRcbiAgb25Db25uZWN0PzogKCkgPT4gdm9pZFxuICBvbkRpc2Nvbm5lY3Q/OiAoKSA9PiB2b2lkXG4gIG9uRXJyb3I/OiAoZXJyb3I6IEV2ZW50KSA9PiB2b2lkXG4gIHJlY29ubmVjdEludGVydmFsPzogbnVtYmVyXG4gIG1heFJlY29ubmVjdEF0dGVtcHRzPzogbnVtYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBXb3JrZmxvd1dlYlNvY2tldENsaWVudCB7XG4gIHByaXZhdGUgd3M6IFdlYlNvY2tldCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgb3B0aW9uczogV2ViU29ja2V0Q2xpZW50T3B0aW9uc1xuICBwcml2YXRlIHJlY29ubmVjdEF0dGVtcHRzID0gMFxuICBwcml2YXRlIHJlY29ubmVjdFRpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgcGluZ1RpbWVyOiBOb2RlSlMuVGltZW91dCB8IG51bGwgPSBudWxsXG4gIHByaXZhdGUgaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgcHJpdmF0ZSBzaG91bGRSZWNvbm5lY3QgPSB0cnVlXG5cbiAgY29uc3RydWN0b3Iob3B0aW9uczogV2ViU29ja2V0Q2xpZW50T3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHJlY29ubmVjdEludGVydmFsOiA1MDAwLFxuICAgICAgbWF4UmVjb25uZWN0QXR0ZW1wdHM6IDEwLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3QoKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGluZyB8fCAodGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSkge1xuICAgICAgICByZXNvbHZlKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gdHJ1ZVxuICAgICAgXG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCA9PT0gJ2h0dHBzOicgPyAnd3NzOicgOiAnd3M6J1xuICAgICAgICBjb25zdCB3c1VybCA9IGAke3Byb3RvY29sfS8vJHt3aW5kb3cubG9jYXRpb24uaG9zdH0vYXBpL3dvcmtmbG93cy93cz93b3JrZmxvd0lkPSR7dGhpcy5vcHRpb25zLndvcmtmbG93SWR9JnRva2VuPSR7dGhpcy5vcHRpb25zLnRva2VufWBcbiAgICAgICAgXG4gICAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHdzVXJsKVxuXG4gICAgICAgIHRoaXMud3Mub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgIGxvZ2dlci5pbmZvKCdXZWJTb2NrZXQgY29ubmVjdGVkJywgeyBcbiAgICAgICAgICAgIHdvcmtmbG93SWQ6IHRoaXMub3B0aW9ucy53b3JrZmxvd0lkLFxuICAgICAgICAgICAgY29tcG9uZW50OiAnd2Vic29ja2V0LWNsaWVudCdcbiAgICAgICAgICB9KVxuICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMFxuICAgICAgICAgIHRoaXMuc3RhcnRQaW5nVGltZXIoKVxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vbkNvbm5lY3Q/LigpXG4gICAgICAgICAgcmVzb2x2ZSgpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndzLm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gSlNPTi5wYXJzZShldmVudC5kYXRhKSBhcyBXZWJTb2NrZXRNZXNzYWdlXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1lc3NhZ2UobWVzc2FnZSlcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBXZWJTb2NrZXQgbWVzc2FnZTonLCBlcnJvcilcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLndzLm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICBsb2dnZXIuaW5mbygnV2ViU29ja2V0IGNsb3NlZCcsIHsgXG4gICAgICAgICAgICBjb2RlOiBldmVudC5jb2RlLFxuICAgICAgICAgICAgcmVhc29uOiBldmVudC5yZWFzb24sXG4gICAgICAgICAgICB3b3JrZmxvd0lkOiB0aGlzLm9wdGlvbnMud29ya2Zsb3dJZCxcbiAgICAgICAgICAgIGNvbXBvbmVudDogJ3dlYnNvY2tldC1jbGllbnQnXG4gICAgICAgICAgfSlcbiAgICAgICAgICB0aGlzLmlzQ29ubmVjdGluZyA9IGZhbHNlXG4gICAgICAgICAgdGhpcy5zdG9wUGluZ1RpbWVyKClcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25EaXNjb25uZWN0Py4oKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdCAmJiB0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgdGhpcy5vcHRpb25zLm1heFJlY29ubmVjdEF0dGVtcHRzISkge1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlY29ubmVjdCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yKVxuICAgICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgICB0aGlzLm9wdGlvbnMub25FcnJvcj8uKGVycm9yKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmICh0aGlzLndzPy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbm5lY3QgdG8gV2ViU29ja2V0JykpXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuaXNDb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkUmVjb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLnN0b3BQaW5nVGltZXIoKVxuICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lcigpXG4gICAgXG4gICAgaWYgKHRoaXMud3MpIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoMTAwMCwgJ0NsaWVudCBkaXNjb25uZWN0JylcbiAgICAgIHRoaXMud3MgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgc2VuZE1lc3NhZ2UobWVzc2FnZTogYW55KSB7XG4gICAgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dlYlNvY2tldCBub3QgY29ubmVjdGVkLCBjYW5ub3Qgc2VuZCBtZXNzYWdlOicsIG1lc3NhZ2UpXG4gICAgfVxuICB9XG5cbiAgc2VuZFVzZXJSZXNwb25zZShhZ2VudElkOiBzdHJpbmcsIHJlc3BvbnNlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd1c2VyX3Jlc3BvbnNlJyxcbiAgICAgIGFnZW50SWQsXG4gICAgICByZXNwb25zZVxuICAgIH0pXG4gIH1cblxuICBzZW5kV29ya2Zsb3dDb250cm9sKGFjdGlvbjogJ3BhdXNlJyB8ICdyZXN1bWUnIHwgJ2NhbmNlbCcpIHtcbiAgICB0aGlzLnNlbmRNZXNzYWdlKHtcbiAgICAgIHR5cGU6ICd3b3JrZmxvd19jb250cm9sJyxcbiAgICAgIGFjdGlvblxuICAgIH0pXG4gIH1cblxuICByZXF1ZXN0U3RhdHVzKCkge1xuICAgIHRoaXMuc2VuZE1lc3NhZ2Uoe1xuICAgICAgdHlwZTogJ3JlcXVlc3Rfc3RhdHVzJ1xuICAgIH0pXG4gIH1cblxuICBwcml2YXRlIGhhbmRsZU1lc3NhZ2UobWVzc2FnZTogV2ViU29ja2V0TWVzc2FnZSkge1xuICAgIC8vIEhhbmRsZSBwb25nIG1lc3NhZ2VzXG4gICAgaWYgKChtZXNzYWdlIGFzIGFueSkudHlwZSA9PT0gJ3BvbmcnKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMub25NZXNzYWdlPy4obWVzc2FnZSlcbiAgfVxuXG4gIHByaXZhdGUgc3RhcnRQaW5nVGltZXIoKSB7XG4gICAgdGhpcy5zdG9wUGluZ1RpbWVyKClcbiAgICB0aGlzLnBpbmdUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMuc2VuZE1lc3NhZ2UoeyB0eXBlOiAncGluZycgfSlcbiAgICB9LCAzMDAwMCkgLy8gUGluZyBldmVyeSAzMCBzZWNvbmRzXG4gIH1cblxuICBwcml2YXRlIHN0b3BQaW5nVGltZXIoKSB7XG4gICAgaWYgKHRoaXMucGluZ1RpbWVyKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMucGluZ1RpbWVyKVxuICAgICAgdGhpcy5waW5nVGltZXIgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZVJlY29ubmVjdCgpIHtcbiAgICB0aGlzLmNsZWFyUmVjb25uZWN0VGltZXIoKVxuICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMrK1xuICAgIFxuICAgIGNvbnN0IGRlbGF5ID0gTWF0aC5taW4oXG4gICAgICB0aGlzLm9wdGlvbnMucmVjb25uZWN0SW50ZXJ2YWwhICogTWF0aC5wb3coMiwgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyAtIDEpLFxuICAgICAgMzAwMDAgLy8gTWF4IDMwIHNlY29uZHNcbiAgICApXG5cbiAgICBsb2dnZXIuaW5mbygnU2NoZWR1bGluZyBXZWJTb2NrZXQgcmVjb25uZWN0JywgeyBcbiAgICAgIGF0dGVtcHQ6IHRoaXMucmVjb25uZWN0QXR0ZW1wdHMsXG4gICAgICBkZWxheU1zOiBkZWxheSxcbiAgICAgIHdvcmtmbG93SWQ6IHRoaXMub3B0aW9ucy53b3JrZmxvd0lkLFxuICAgICAgY29tcG9uZW50OiAnd2Vic29ja2V0LWNsaWVudCdcbiAgICB9KVxuICAgIFxuICAgIHRoaXMucmVjb25uZWN0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICh0aGlzLnNob3VsZFJlY29ubmVjdCkge1xuICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignUmVjb25uZWN0IGZhaWxlZDonLCBlcnJvcilcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LCBkZWxheSlcbiAgfVxuXG4gIHByaXZhdGUgY2xlYXJSZWNvbm5lY3RUaW1lcigpIHtcbiAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVjb25uZWN0VGltZXIpXG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVyID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGdldCBpc0Nvbm5lY3RlZCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy53cz8ucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU5cbiAgfVxuXG4gIGdldCBjb25uZWN0aW9uU3RhdGUoKTogc3RyaW5nIHtcbiAgICBpZiAoIXRoaXMud3MpIHJldHVybiAnZGlzY29ubmVjdGVkJ1xuICAgIFxuICAgIHN3aXRjaCAodGhpcy53cy5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIFdlYlNvY2tldC5DT05ORUNUSU5HOiByZXR1cm4gJ2Nvbm5lY3RpbmcnXG4gICAgICBjYXNlIFdlYlNvY2tldC5PUEVOOiByZXR1cm4gJ2Nvbm5lY3RlZCdcbiAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NJTkc6IHJldHVybiAnY2xvc2luZydcbiAgICAgIGNhc2UgV2ViU29ja2V0LkNMT1NFRDogcmV0dXJuICdkaXNjb25uZWN0ZWQnXG4gICAgICBkZWZhdWx0OiByZXR1cm4gJ3Vua25vd24nXG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbIldvcmtmbG93V2ViU29ja2V0Q2xpZW50IiwiY29ubmVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaXNDb25uZWN0aW5nIiwid3MiLCJyZWFkeVN0YXRlIiwiV2ViU29ja2V0IiwiT1BFTiIsInByb3RvY29sIiwid2luZG93IiwibG9jYXRpb24iLCJ3c1VybCIsImhvc3QiLCJvcHRpb25zIiwid29ya2Zsb3dJZCIsInRva2VuIiwib25vcGVuIiwibG9nZ2VyIiwiaW5mbyIsImNvbXBvbmVudCIsInJlY29ubmVjdEF0dGVtcHRzIiwic3RhcnRQaW5nVGltZXIiLCJvbkNvbm5lY3QiLCJvbm1lc3NhZ2UiLCJldmVudCIsIm1lc3NhZ2UiLCJKU09OIiwicGFyc2UiLCJkYXRhIiwiaGFuZGxlTWVzc2FnZSIsImVycm9yIiwiY29uc29sZSIsIm9uY2xvc2UiLCJjb2RlIiwicmVhc29uIiwic3RvcFBpbmdUaW1lciIsIm9uRGlzY29ubmVjdCIsInNob3VsZFJlY29ubmVjdCIsIm1heFJlY29ubmVjdEF0dGVtcHRzIiwic2NoZWR1bGVSZWNvbm5lY3QiLCJvbmVycm9yIiwib25FcnJvciIsIkNPTk5FQ1RJTkciLCJFcnJvciIsImRpc2Nvbm5lY3QiLCJjbGVhclJlY29ubmVjdFRpbWVyIiwiY2xvc2UiLCJzZW5kTWVzc2FnZSIsInNlbmQiLCJzdHJpbmdpZnkiLCJ3YXJuIiwic2VuZFVzZXJSZXNwb25zZSIsImFnZW50SWQiLCJyZXNwb25zZSIsInR5cGUiLCJzZW5kV29ya2Zsb3dDb250cm9sIiwiYWN0aW9uIiwicmVxdWVzdFN0YXR1cyIsIm9uTWVzc2FnZSIsInBpbmdUaW1lciIsInNldEludGVydmFsIiwiY2xlYXJJbnRlcnZhbCIsImRlbGF5IiwiTWF0aCIsIm1pbiIsInJlY29ubmVjdEludGVydmFsIiwicG93IiwiYXR0ZW1wdCIsImRlbGF5TXMiLCJyZWNvbm5lY3RUaW1lciIsInNldFRpbWVvdXQiLCJjYXRjaCIsImNsZWFyVGltZW91dCIsImlzQ29ubmVjdGVkIiwiY29ubmVjdGlvblN0YXRlIiwiQ0xPU0lORyIsIkNMT1NFRCIsImNvbnN0cnVjdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/websocket-client.ts\n"));

/***/ })

});